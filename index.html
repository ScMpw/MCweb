<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Monte Carlo Simulation</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100 p-6">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useRef } = React;
    const { jsPDF } = window.jspdf;

    function MonteCarloSimulation() {
      const [epicName, setEpicName] = useState("");
      const [piName, setPiName] = useState("");
      const [originalEstimate, setOriginalEstimate] = useState("");
      const [sprintValues, setSprintValues] = useState(Array(6).fill(""));
      const [textOutput, setTextOutput] = useState("");
      const chartRefs = {
        worst: useRef(null),
        mixed: useRef(null),
        best: useRef(null)
      };

      const runSimulation = () => {
        const sprintNumbers = sprintValues.map(Number).filter(n => !isNaN(n));
        const estimate = Number(originalEstimate);

        if (sprintNumbers.length < 6 || isNaN(estimate) || estimate <= 0) {
          alert("Please fill in all sprint values and original estimate.");
          return;
        }

        const sorted = [...sprintNumbers].sort((a, b) => a - b);
        const worst = sorted.slice(0, 2);
        const best = sorted.slice(-2);
        const mixed = sprintNumbers;

        const simulate = (velocities) => {
          const results = [];
          for (let i = 0; i < 10000; i++) {
            let total = 0, sprints = 0;
            while (total < estimate) {
              total += velocities[Math.floor(Math.random() * velocities.length)];
              sprints++;
            }
            results.push(sprints);
          }
          return results.sort((a, b) => a - b);
        };

        const buildPercentileData = (data) => {
          const labels = [];
          const values = [];
          for (let i = 0; i <= 100; i += 5) {
            const index = Math.floor((i / 100) * (data.length - 1));
            labels.push(i);
            values.push(data[index]);
          }
          return { labels, values };
        };

        const renderChart = (ctx, label, data, color) => {
          if (ctx.chart) ctx.chart.destroy();
          ctx.chart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: data.labels,
              datasets: [{
                label,
                data: data.values,
                backgroundColor: color,
                borderColor: color,
                fill: false,
                tension: 0.3
              }]
            },
            options: {
              responsive: true,
              scales: {
                x: {
                  title: { display: true, text: 'Probability of Completion (%)' },
                  ticks: { stepSize: 5, min: 0, max: 100 }
                },
                y: {
                  title: { display: true, text: 'Sprints Needed' }
                }
              }
            }
          });
        };

        const worstResult = simulate(worst);
        const mixedResult = simulate(mixed);
        const bestResult = simulate(best);

        const p95 = arr => arr[Math.floor(0.95 * arr.length)];
        const inputData = `Sprint Values: ${sprintNumbers.join(", ")}`;
        const output = `Epic: ${epicName}\nPI: ${piName}\n${inputData}\n\nWorst (95%): ${p95(worstResult)}\nMixed (95%): ${p95(mixedResult)}\nBest (95%): ${p95(bestResult)}`;
        setTextOutput(output);

        renderChart(chartRefs.worst.current.getContext('2d'), 'Worst Case', buildPercentileData(worstResult), '#ef4444');
        renderChart(chartRefs.mixed.current.getContext('2d'), 'Mixed Case', buildPercentileData(mixedResult), '#3b82f6');
        renderChart(chartRefs.best.current.getContext('2d'), 'Best Case', buildPercentileData(bestResult), '#10b981');
      };

      const downloadPDF = () => {
        const doc = new jsPDF();
        doc.setFontSize(12);
        const lines = doc.splitTextToSize(textOutput, 180);
        doc.text(lines, 10, 10);

        const addChartToPDF = (ref, yPos, label) => {
          const imgData = ref.current.toDataURL("image/png");
          doc.text(label, 10, yPos - 5);
          doc.addImage(imgData, 'PNG', 10, yPos, 180, 60);
        };

        addChartToPDF(chartRefs.worst, 60, 'Worst Case');
        addChartToPDF(chartRefs.mixed, 130, 'Mixed Case');
        addChartToPDF(chartRefs.best, 200, 'Best Case');

        doc.save(`${epicName}_${piName}_simulation_results.pdf`);
      };

      return (
        <div className="max-w-4xl mx-auto bg-white p-6 rounded shadow">
          <h1 className="text-2xl font-bold mb-4">Monte Carlo Simulation</h1>
          <input className="border p-2 w-full mb-2" placeholder="Epic Name" value={epicName} onChange={e => setEpicName(e.target.value)} />
          <input className="border p-2 w-full mb-2" placeholder="PI Name & Year" value={piName} onChange={e => setPiName(e.target.value)} />
          <input className="border p-2 w-full mb-2" placeholder="Original Estimate" type="number" value={originalEstimate} onChange={e => setOriginalEstimate(e.target.value)} />
          <div className="grid grid-cols-2 gap-2 mb-4">
            {sprintValues.map((val, idx) => (
              <input key={idx} className="border p-2" placeholder={`Sprint ${idx + 1}`} type="number" value={val} onChange={e => {
                const newVals = [...sprintValues];
                newVals[idx] = e.target.value;
                setSprintValues(newVals);
              }} />
            ))}
          </div>
          <button className="bg-blue-500 text-white px-4 py-2 rounded w-full mb-2" onClick={runSimulation}>Run Simulation</button>
          <button className="bg-green-500 text-white px-4 py-2 rounded w-full" onClick={downloadPDF}>Download PDF</button>
          {textOutput && (
            <pre className="mt-4 p-4 bg-gray-100 rounded whitespace-pre-wrap">{textOutput}</pre>
          )}
          <div className="mt-6 space-y-8">
            <canvas ref={chartRefs.worst} className="w-full h-64"></canvas>
            <canvas ref={chartRefs.mixed} className="w-full h-64"></canvas>
            <canvas ref={chartRefs.best} className="w-full h-64"></canvas>
          </div>
        </div>
      );
    }

    ReactDOM.render(<MonteCarloSimulation />, document.getElementById("root"));
  </script>
</body>
</html>
